; *  dabusb-fw - dabusb_fw.c                                                  
; *                                                                           
; * Copyright (C) 2010 Felipe C. da S. Sanches <juca@members.fsf.org>         
; * Copyright (C) 1999 BayCom GmbH                                            
; *                                                                           
; *  This program is free software, licensed under the terms of the GNU       
; *  General Public License as published by the Free Software Foundation,     
; *  either version 2 of the License, or (at your option) any later version.  
; *  You should have received a copy of the GNU General Public License        
; *  along with this program.  If not, see <http://www.gnu.org/licenses/>.    
;
;
; * Copyright (C) 1999 BayCom GmbH
; *
; * Redistribution and use in source and binary forms, with or without
; * modification, are permitted provided that redistributions of source
; * code retain the above copyright notice and this comment without
; * modification.
;
;  D52 V3.4.1 8052 Disassembly of dabusb_fw.bin
;  2010/12/20 14:48
;
;	Register/Memory Equates
;
rb0r0=0
rb0r1=1
rb0r2=2
rb0r3=3
rb0r4=4
rb0r5=5
rb0r6=6
rb0r7=7

;----------
;constants:

FPGA_CLEAR=0x2a
FPGA_LOAD_BITSTREAM=0x2b
FPGA_INIT=0x2c
INTERNAL_8BITS = 0
EXTERNAL_16BITS = 1
INTERNAL_16BITS = 2
EXTERNAL_8BITS = 3

;----------
;variables:

variable20=0x20
variable21=0x21
variable22=0x22
variable23=0x23
got_EP2IN_data=0x30
got_EP2OUT_data=0x31
variable32=0x32
pB0_pB2=0x33 	;THIS VARIABLE NAME IS NOT DEFINITIVE. 
							; THIS VAR SEEMS TO STORE THE STATE OF THE
							; GENERAL PURPOSE INPUT PINS PB0 AND PB2
variable34=0x34
variable35=0x35
variable36=0x36
variable37=0x37
variable38=0x38
LCD_CHAR_POSITION=0x39
variable3a=0x3a
variable3b=0x3b
variable3c=0x3c
variable3d=0x3d
variable3e=0x3e
variable3f=0x3f
variable40=0x40
variable41=0x41
variable42=0x42
variable43=0x43
variable44=0x44
variable45=0x45
variable46=0x46
variable47=0x47
variable48=0x48
variable59=0x59
variable5a=0x5a
variable6b=0x6b
variable6c=0x6c
CHAR_TO_PRINT=0x6d
CHAR_COL=0x6e
CHAR_ROW=0x6f
STRING_ADDR_LOW=0x70
STRING_ADDR_HI=0x71
STRING_ADDRESSING_MODE=0x72
variable73=0x73
variable74=0x74
variable75=0x75
variable76=0x76
variable7f=0x7f

;----------
;EZ-USB additional SFRs:

DPL1=0x84
DPH1=0x85
DPS=0x86 ; dptr selector
CKCON=0x8E
SPC_FNC=0x8F
EXIF=0x91
MPAGE=0x92
SCON1=0xC0
SBUF1=0xC1
EICON=0xD8
EIE=0xE8
EIP=0xF8

;----------
;EZ-USB registers

OUT2BUF=0x7dc0
OUT2BUF_OFFSET1=0x7dc1
OUT2BUF_OFFSET2=0x7dc2
OUT2BUF_OFFSET3=0x7dc3
OUT2BUF_LASTBYTE=0x7dff
OUT0BUF=0x7ec0
OUT0BUF_OFFSET1=0x7ec1
IN0BUF=0x7f00
IN0BUF_OFFSET1=0x7f01
IN8DATA=0x7f68
IN9DATA=0x7f69
CPUCS=0x7f92
PORTACFG=0x7f93
PORTBCFG=0x7f94
PORTCCFG=0x7f95
OUTA=0x7f96
OUTB=0x7f97
OUTC=0x7f98
PINSB=0x7f9a
OEA=0x7f9c
OEB=0x7f9d
OEC=0x7f9e
ISOCTL=0x7fa1
I2CS=0x7fa5
I2CDAT=0x7fa6
IN07IRQ=0x7fa9
OUT07IRQ=0x7faa
USBIRQ=0x7fab
IN07IEN=0x7fac
OUT07IEN=0x7fad
USBIEN=0x7fae
USBBAV=0x7faf
EP0CS=0x7fb4
IN0BC=0x7fb5
IN2BC=0x7fb9
OUT0BC=0x7fc5
OUT2BC=0x7fc9
SUDPTRH=0x7fd4
SUDPTRL=0x7fd5
USBCS=0x7fd6
USBPAIR=0x7fdd
IN07VAL=0x7fde
OUT07VAL=0x7fdf
INISOVAL=0x7fe0
OUTISOVAL=0x7fe1
FASTXFR=0x7fe2
SETUPDAT=0x7fe8
OUT8ADDR=0x7ff0
OUT9ADDR=0x7ff1
OUT10ADDR=0x7ff2
OUT11ADDR=0x7ff3
OUT12ADDR=0x7ff4
OUT13ADDR=0x7ff5
OUT14ADDR=0x7ff6
OUT15ADDR=0x7ff7
IN8ADDR=0x7ff8
IN9ADDR=0x7ff9
IN10ADDR=0x7ffa
IN11ADDR=0x7ffb
IN12ADDR=0x7ffc
IN13ADDR=0x7ffd
IN14ADDR=0x7ffe
IN15ADDR=0x7fff

;There is something mapped to these addresses. I'll have to check it later.
X7fe9=0x7fe9
X7fea=0x7fea
X7feb=0x7feb
X7fec=0x7fec
X7fed=0x7fed
X7fee=0x7fee
X7fef=0x7fef

;these seem to be the addresses to which the FPGA is memory mapped
X8800=0x8800
X8802=0x8802
X8803=0x8803
X880b=0x880b
X880f=0x880f

.area   CODE  (ABS)

.org	0x00

X0000:
	ajmp	X0000_

.org 0x03
ExternalInterrupt0:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x0b
TimerInterrupt0:
	ljmp	INTERRUPT_NOT_HANDLED 

.org	0x13
ExternalInterrupt1:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x1b
TimerInterrupt1:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x23
SerialPort0Int:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x2b
Timer2Int:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x33
RESUME:
	ljmp	RESUME_INTERRUPT_HANDLER

.org	0x3b
SerialPort1Int:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x43
INT2:
	ljmp	USBInterruptAutoVector

.org	0x4b
INT3:
	ljmp	INTERRUPT_NOT_HANDLED ;I2C interrupt

.org	0x53
INT4:
	ljmp	INTERRUPT_NOT_HANDLED

.org	0x5b
INT5:
	ljmp	INT5_HANDLER

.org	0x63
INT6:
	ljmp	INT6_HANDLER

.org	0x100
USBInterruptAutoVector:
	ljmp	SUDAV
	.db 0
	ljmp	SOF
	.db 0
	ljmp	SUTOK
	.db 0
	ljmp	SUSPEND
	.db 0
	ljmp	USBRES
	.db 0
	reti
	.db 0,0,0
	reti
	.db 0,0,0
	ljmp	EP0_OUT
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	EP2_IN
	.db 0
	ljmp	EP2_OUT
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000
	.db 0
	ljmp	X0000

X0000_:
	mov	sp,#0x7f
	mov	a,dpl
	lcall	init_usb
FOREVER:	ajmp	FOREVER

INTERRUPT_NOT_HANDLED:	reti	

INT6_HANDLER:
	;I guess that the radio receiver sets an interrupt (INT6)
	; whenever it has more data to send to the PC
	push	psw
	push	DPS
	push	dpl
	push	dph
	push	acc

	;set bit pB7 (general purpose output pin)
	; I suppose it means "give me some radio data"
	mov	dptr,#OUTB
	movx	a,@dptr
	orl	a,#0x80
	movx	@dptr,a

	;fast transfer 32 bytes from external FIFO to prepare
	; an isochronous transfer via EP9IN
	;
	; Read pages Section 8.6 "Fast Transfers" in the
	; Cypress EZ-USB (AN21XX) Technical Reference Manual
	mov	dptr,#IN9DATA
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a

	mov	dptr,#OUTB
	movx	a,@dptr
	anl	a,variable7f ;this seems to be the only reference to this variable!
	movx	@dptr,a

;check alternate function pin pB4: INT4
	mov	dptr,#PINSB
	movx	a,@dptr
	jnb	acc.4,X01cc

	;fast transfer from external FIFO to EP8IN
	;maybe this is radio metadata?
	mov	dptr,#IN8DATA
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
X01cc:
	mov	a,i2cfg
	clr	acc.3
	mov	i2cfg,a

	pop	acc
	pop	dph
	pop	dpl
	pop	DPS
	pop	psw
	reti	

sleep_a_bit:
	mov	DPS,#0
	mov	dptr,#0xffc3
	mov	r4,#5
sleep_loop:
	inc	dptr
	mov	a,dpl
	orl	a,dph
	jnz	sleep_loop
	ret

SOF:
	push	acc
	push	b
	push	dpl
	push	dph
	push	rb0r2
	push	rb0r3
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#X8800
	movx	a,@dptr
	mov	variable41,a ;this is the only usage of this variable. Is it useless?

	mov	dptr,#USBIRQ
	mov	a,#2
	movx	@dptr,a

	mov	dptr,#USBIRQ
	mov	a,#2
	movx	@dptr,a

	mov	a,variable32
	jz	X0240
	mov	r2,#0
	mov	r3,#0
X0223:
	clr	c
	mov	a,r2
	subb	a,#0x18
	mov	a,r3
	xrl	a,#0x80
	subb	a,#0x80
	jnc	X0240
	mov	dptr,#IN9DATA
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	movx	@dptr,a
	inc	r2
	cjne	r2,#0,X0223
	inc	r3
	sjmp	X0223
X0240:
	pop	DPS
	pop	psw
	pop	rb0r3
	pop	rb0r2
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

SUTOK:
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#USBIRQ
	mov	a,#4
	movx	@dptr,a

	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

SUSPEND:
	push	acc
	push	b
	push	dpl
	push	dph
	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	push	rb0r6
	push	rb0r7
	push	rb0r0
	push	rb0r1
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#USBIRQ
	mov	a,#8
	movx	@dptr,a

	mov	CHAR_COL,#0
	mov	CHAR_ROW,#2
	lcall	set_cursor_position

	mov	STRING_ADDR_LOW,	<string_SUSPEND
	mov	STRING_ADDR_HI,		>string_SUSPEND
	mov	STRING_ADDRESSING_MODE, INTERNAL_16BITS
	lcall	print_string

	mov	dptr,#USBCS
	clr	a
	movx	@dptr,a

	mov	i2cfg,#0x20
	pop	DPS
	pop	psw
	pop	rb0r1
	pop	rb0r0
	pop	rb0r7
	pop	rb0r6
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

USBRES:
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#USBIRQ
	mov	a,#0x10
	movx	@dptr,a

	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

RESUME_INTERRUPT_HANDLER:
	push	acc
	push	b
	push	dpl
	push	dph
	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	push	rb0r6
	push	rb0r7
	push	rb0r0
	push	rb0r1
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	CHAR_COL,#0
	mov	CHAR_ROW,#2
	lcall	set_cursor_position

	mov	STRING_ADDR_LOW,	<string_RESUME
	mov	STRING_ADDR_HI,		>string_RESUME
	mov	STRING_ADDRESSING_MODE, INTERNAL_16BITS
	lcall	print_string

	mov	dptr,#USBCS
	mov	a,#2
	movx	@dptr,a

	mov	dptr,#USBCS
	mov	a,#6
	movx	@dptr,a

	mov	i2cfg,#0x10
	pop	DPS
	pop	psw
	pop	rb0r1
	pop	rb0r0
	pop	rb0r7
	pop	rb0r6
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

X0372:
	mov	dptr,#I2CS
	mov	a,#0x80
	movx	@dptr,a
	mov	dptr,#I2CDAT
	mov	a,#0x9a
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CDAT
	mov	a,variable42
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CDAT
	mov	a,variable43
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CS
	mov	a,#0x40
	movx	@dptr,a
	ret	

X039a:
	mov	dptr,#I2CS
	mov	a,#0x80
	movx	@dptr,a
	mov	dptr,#I2CDAT
	mov	a,#0x9a
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CDAT
	mov	a,variable44
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CDAT
	mov	a,variable45
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CDAT
	mov	a,variable46
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CS
	mov	a,#0x40
	movx	@dptr,a
	ret	

X03cb:
	mov	variable44,#2
	mov	variable45,#0
	mov	variable46,#0
	lcall	X039a
	mov	variable42,#3
	mov	variable43,#0
	lcall	X0372
	ret	

X03e1:
	mov	dptr,#X8800
	mov	a,variable36
	movx	@dptr,a

	mov	dptr,#X8800
	mov	a,#0x10
	add	a,variable36
	movx	@dptr,a

	lcall	sleep_a_bit

	mov	variable42,#1
	mov	variable43,#0x18
	lcall	X0372

	mov	variable44,#2
	mov	variable45,#0
	mov	variable46,#0
	lcall	X039a

	mov	variable42,#3
	mov	variable43,#0x44
	lcall	X0372
	ret	

does_this_routine_get_called:;?
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#OUT07IRQ
	mov	a,#2
	movx	@dptr,a

	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti

EP2_IN:
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#IN07IRQ
	mov	a,#4
	movx	@dptr,a

	mov	got_EP2IN_data,#1
	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

EP2_OUT:
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#OUT07IRQ
	mov	a,#4
	movx	@dptr,a

	mov	got_EP2OUT_data,#1
	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

another_routine_that_I_think_never_gets_called:
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear EZUSB I²C interrupt (INT3)
	clr	acc.5
	mov	EXIF,a

	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

INT5_HANDLER:
	push	acc
	push	b
	push	dpl
	push	dph
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear external INT5 IRQ
	clr	acc.7
	mov	EXIF,a

	pop	DPS
	pop	psw
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

X04e2:
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r2,a
	mov	variable20,r2
	mov	dptr,#OUTA
	clr	a
	movx	@dptr,a
	ret	

X04ef:
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r2,a
	mov	variable21,r2
	ret	

X04f7:
	mov	dptr,#X1713
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X1715
	movx	a,@dptr
	mov	r3,a
	mov	a,#0x80
	add	a,r2
	mov	r2,a
	mov	a,#0x80
	add	a,r3
	mov	r3,a
	mov	a,r2
	rr	a
	rr	a
	anl	a,#0x3f
	mov	r4,a
	mov	a,r2
	swap	a
	rl	a
	anl	a,#0x1f
	mov	r2,a
	add	a,r4
	mov	r2,a
	mov	a,r3
	rr	a
	rr	a
	anl	a,#0x3f
	mov	r4,a
	mov	a,r3
	swap	a
	rl	a
	anl	a,#0x1f
	mov	r3,a
	add	a,r4
	mov	r3,a
	mov	dptr,#X170a
	movx	a,@dptr
	mov	r4,a
	jz	X052e
	mov	r2,#0
X052e:
	mov	dptr,#X170c
	movx	a,@dptr
	mov	r4,a
	jz	X0537
	mov	r3,#0
X0537:
	mov	a,r2
	add	a,r3
	mov	r4,a
	clr	c
	rrc	a
	mov	variable3a,a
	mov	variable44,#2
	mov	variable45,r3
	mov	variable46,r2
	lcall	X039a

	mov	CHAR_COL,#8
	mov	CHAR_ROW,#0
	lcall	set_cursor_position

	mov	STRING_ADDR_LOW,	<string_Vol
	mov	STRING_ADDR_HI,		>string_Vol
	mov	STRING_ADDRESSING_MODE, INTERNAL_16BITS
	lcall	print_string

	mov	variable73,variable3a
	lcall	X11a0
	ret

X0564:

;toggle state of general purpose pin pA7:
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#OUTA
	mov	a,#0x80
	xrl	a,rb0r2
	movx	@dptr,a

	mov	dptr,#X7feb
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r3,a
	mov	dptr,#X7fef
	movx	a,@dptr
	mov	r4,a
	rlc	a
	subb	a,acc
	mov	r5,a
	mov	rb0r5,r4
	mov	r4,#0
	mov	dptr,#X7fee
	movx	a,@dptr
	mov	r6,a
	rlc	a
	subb	a,acc
	mov	r7,a
	mov	a,r4
	add	a,r6
	mov	r4,a
	mov	a,r5
	addc	a,r7
	mov	r5,a
	mov	dptr,#X7fe9
	movx	a,@dptr
	mov	r6,a
	cjne	r6,#1,X05a1
	sjmp	X05a4
X05a1:
	ljmp	X05f9
X05a4:
	cjne	r4,#1,X05c8
	cjne	r5,#0,X05c8
	mov	a,r2
	swap	a
	rr	a
	anl	a,#0x0f8
	mov	r4,a
	mov	a,r3
	add	a,acc
	mov	r5,a
	add	a,r4
	add	a,#0
	mov	r4,a
	clr	a
	addc	a,#0x17
	mov	r5,a
	mov	dptr,#OUT0BUF
	movx	a,@dptr
	mov	r6,a
	mov	dpl,r4
	mov	dph,r5
	movx	@dptr,a
	sjmp	X05f9
X05c8:
	mov	a,r2
	swap	a
	rr	a
	anl	a,#0x0f8
	mov	r2,a
	mov	a,r3
	add	a,acc
	mov	r3,a
	add	a,r2
	mov	r2,a
	add	a,#0
	mov	r3,a
	clr	a
	addc	a,#0x17
	mov	r4,a
	mov	dptr,#OUT0BUF
	movx	a,@dptr
	mov	r5,a
	mov	dpl,r3
	mov	dph,r4
	movx	@dptr,a
	mov	a,#1
	add	a,r2
	add	a,#0
	mov	r2,a
	clr	a
	addc	a,#0x17
	mov	r3,a
	mov	dptr,#OUT0BUF_OFFSET1
	movx	a,@dptr
	mov	r4,a
	mov	dpl,r2
	mov	dph,r3
	movx	@dptr,a
X05f9:
	mov	variable38,#1
	ret	

EP0_OUT:
	push	acc
	push	b
	push	dpl
	push	dph
	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	push	rb0r6
	push	rb0r7
	push	rb0r0
	push	rb0r1
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#OUT07IRQ
	mov	a,#1
	movx	@dptr,a
	lcall	X0564
	mov	variable37,#0

	pop	DPS
	pop	psw
	pop	rb0r1
	pop	rb0r0
	pop	rb0r7
	pop	rb0r6
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

X064e:
	mov	dptr,#X7feb
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r3,a
	mov	dptr,#X7fee
	movx	a,@dptr
	mov	r4,a
	rlc	a
	subb	a,acc
	mov	r5,a

;toggle state of general purpose pin pA7:
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r6,a
	mov	dptr,#OUTA
	mov	a,#0x80
	xrl	a,rb0r6
	movx	@dptr,a

	mov	dptr,#IN0BUF
	mov	a,#1
	movx	@dptr,a
	mov	a,r2
	swap	a
	rr	a
	anl	a,#0x0f8
	mov	r6,a
	mov	a,r3
	add	a,acc
	mov	r3,a
	add	a,r6
	mov	r6,a
	add	a,#0
	mov	r3,a
	clr	a
	addc	a,#0x17
	mov	r7,a
	mov	dpl,r3
	mov	dph,r7
	movx	a,@dptr
	mov	r3,a
	mov	a,#1
	add	a,r6
	add	a,#0
	mov	r6,a
	clr	a
	addc	a,#0x17
	mov	r7,a
	mov	dpl,r6
	mov	dph,r7
	movx	a,@dptr
	mov	r6,a
	mov	dptr,#X7fe9
	movx	a,@dptr
	mov	r7,a
	cjne	r7,#0x81,X06af
	mov	dptr,#IN0BUF
	mov	a,r3
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	mov	a,r6
	movx	@dptr,a
X06af:
	mov	dptr,#X7fe9
	movx	a,@dptr
	mov	r3,a
	cjne	r3,#0x82,X06d1
	cjne	r2,#1,X06c6
	mov	dptr,#IN0BUF
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	clr	a
	movx	@dptr,a
	sjmp	X06d1
;
X06c6:
	mov	dptr,#IN0BUF
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	mov	a,#0x0b5
	movx	@dptr,a
X06d1:
	mov	dptr,#X7fe9
	movx	a,@dptr
	mov	r3,a
	cjne	r3,#0x83,X06f4
	cjne	r2,#1,X06e9
	mov	dptr,#IN0BUF
	mov	a,#1
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	clr	a
	movx	@dptr,a
	sjmp	X06f4
;
X06e9:
	mov	dptr,#IN0BUF
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	mov	a,#0x12
	movx	@dptr,a
X06f4:
	mov	dptr,#X7fe9
	movx	a,@dptr
	mov	r3,a
	cjne	r3,#0x84,X0718
	cjne	r2,#1,X070c
	mov	dptr,#IN0BUF
	mov	a,#1
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	clr	a
	movx	@dptr,a
	sjmp	X0718
;
X070c:
	mov	dptr,#IN0BUF
	mov	a,#0x80
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	mov	a,#1
	movx	@dptr,a
X0718:
	mov	dptr,#IN0BC
	mov	a,r4
	movx	@dptr,a
	ret	

X071e:
	mov	variable36,#0x0d
	mov	dptr,#X8800
	mov	a,#0x1d
	movx	@dptr,a

	mov	variable6b,#0x80
	mov	variable6c,#0x3c
	lcall	X10e2

	mov	variable6b,#0x80
	mov	variable6c,#0x0f
	lcall	X10e2

	mov	variable6b,#0x80
	mov	variable6c,#6
	lcall	X10e2

	mov	variable6b,#0x80
	mov	variable6c,#1
	lcall	X10e2

;sleep_a_lot:
	mov	r2,#0
X074d:	cjne	r2,#0x0ff,X0750
X0750:	jnc	X075c
	push	rb0r2
	lcall	sleep_a_bit
	pop	rb0r2
	inc	r2
	sjmp	X074d

X075c:
	mov	variable6b,#0x80
	mov	variable6c,#0x3c
	lcall	X10e2

	mov	variable6b,#0x80
	mov	variable6c,#0x0f
	lcall	X10e2
	ret

;TODO: I am not sure whether "init_usb" is a precise name for this routine 
init_usb:
	;enable isochronous endpoints
	mov	dptr,#ISOCTL
	clr	a
	movx	@dptr,a

	;enable auto-vector feature for handling usb interrupts
	mov	dptr,#USBBAV
	mov	a,#1
	movx	@dptr,a

	;enable internal 24MHz clock
	mov	dptr,#CPUCS
	mov	a,#2
	movx	@dptr,a

	mov	pwcm,#0x31	;TODO

	;select mode 1 for timer0: 16 bit counter
	;select mode 2 for timer1: 8 bit counter with auto-reload
	;both timers are clocked by the internal 24MHz clock
	mov	tmod,#0x21

	mov	tcon,#0
	mov	t2con,#0
;STRANGELY THE TIMERS ARE INITIALY DISABLED AND I SEE NO CODE ACTUALLY ENABLING THEM...
;perhaps these timers are used for the serial port interface

	mov	th1,#0x40 ;reload value
	mov	scon,#0x40 ; set mode 1 for serial port 0 
	mov	p4,#0x40
	mov	pcon,#0

;It seems to me that these timers are not used by 8051 code (timer interrupts
; are not handled and no routine checks the timer bits in the TCON SFR). So
; I think that these timers are only feeding clock signals to the FPGA logic
; through T0OUT/T1OUT pins.

;Timer 0 counts from 0x0 to 0x10000, so 2^16 increments.
;base freq is 24MHz/12 = 2MHz
;Timer1 freq = 2MHz/65536 = 30.52 Hz

;Timer 1 counts from 0x40 to 0x100, so 12*16 increments.
;base freq is 24MHz/12 = 2MHz
;Timer1 freq = 2MHz/(12*16) = 10.42 kHz


	mov	variable20,#0
	mov	variable21,#0
	mov	variable22,#0
	mov	variable23,#0
	mov	variable47,#0
X07a7:
	clr	c
	mov	a,variable47
	subb	a,#0x20
	jnc	X07bf
	mov	a,variable47
	add	a,#0
	mov	dpl,a
	clr	a
	addc	a,#0x17
	mov	dph,a
	clr	a
	movx	@dptr,a
	inc	variable47
	sjmp	X07a7
;
X07bf:
	clr	a
	mov	variable40,a
	mov	variable3f,a
	mov	variable3c,a
	mov	variable3b,a
	mov	variable3e,a
	mov	variable3d,a
	mov	variable32,a
	mov	variable37,a
	mov	LCD_CHAR_POSITION,a

;setup alternate function pins:
;pA2: (OUT) EZUSB output enable
;pA3: (OUT) EZUSB chip select
;pA4: (OUT) EZUSB fast write strobe
;pA5: (OUT) EZUSB fast read strobe
	mov	dptr,#PORTACFG
	mov	a,#0x3c ; 0011 1100
	movx	@dptr,a

;all pins are output
;Port A general purpose pins seem to be connected to the FPGA pins used
; to configure the its bitstream  
	mov	dptr,#OEA
	mov	a,#0xff
	movx	@dptr,a

;set general purpose output pin pA7 TODO: what is connected to this pin?
; (seems to be some kind of clock since some routines keep toggling its state)
	mov	dptr,#OUTA
	mov	a,#0x80
	movx	@dptr,a

;setup alternate function pins:
;pB4: (IN) INT4
;pB5: (IN) INT5
;pB6: (IN) INT6
	mov	dptr,#PORTBCFG
	mov	a,#0x70 ; 0111 0000
	movx	@dptr,a

; All general purpose pins are configured as output
; TODO: what is mapped to these pins?
	mov	dptr,#OEB
	mov	a,#0x8f ; 1000 1111
	movx	@dptr,a

	mov	dptr,#OUTB
	clr	a
	movx	@dptr,a

;setup alternate function pins:
;pC1: (OUT) UART0 transmit data
;pC6: (OUT) write strobe
;pC7: (OUT) read strobe
	mov	dptr,#PORTCCFG
	mov	a,#0xc2 ; 1100 0010
	movx	@dptr,a

;general purpose pins are 2 outputs and 3 inputs
; but just pin pC3 seems to be relevant (used for clearing the FPGA).
	mov	dptr,#OEC
	mov	a,#0x28 ; 0010 1000
	movx	@dptr,a

	mov	dptr,#OUTC
	mov	a,#0x28
	movx	@dptr,a

;initializing addresses of isochronous endpoints.
; We'll use only ep8 and ep9
	clr	a
	mov	dptr,#OUT8ADDR
	movx	@dptr,a
	mov	dptr,#OUT9ADDR
	movx	@dptr,a
	mov	dptr,#OUT10ADDR
	movx	@dptr,a
	mov	dptr,#OUT11ADDR
	movx	@dptr,a
	mov	dptr,#OUT12ADDR
	movx	@dptr,a
	mov	dptr,#OUT13ADDR
	movx	@dptr,a
	mov	dptr,#OUT14ADDR
	movx	@dptr,a
	mov	dptr,#OUT15ADDR
	movx	@dptr,a

;EP8IN FIFO: 00h-37h (56 bytes)
	mov	dptr,#IN8ADDR
	movx	@dptr,a

;EP9IN FIFO: 38h-9Fh (104 bytes)
	mov	dptr,#IN9ADDR
	mov	a,#0x38
	movx	@dptr,a

	mov	a,#0xA0
	mov	dptr,#IN10ADDR
	movx	@dptr,a
	mov	dptr,#IN11ADDR
	movx	@dptr,a
	mov	dptr,#IN12ADDR
	movx	@dptr,a
	mov	dptr,#IN13ADDR
	movx	@dptr,a
	mov	dptr,#IN14ADDR
	movx	@dptr,a
	mov	dptr,#IN15ADDR
	movx	@dptr,a

;setup EP8IN and EP9IN as valid
	mov	dptr,#INISOVAL
	mov	a,#3
	movx	@dptr,a

;setup EP8OUT as valid
	mov	dptr,#OUTISOVAL
	mov	a,#1
	movx	@dptr,a

;set ISOSEND0=1
; With this, the USB core will send zero-length packets
; when the IN FIFO is empty 
	mov	dptr,#USBPAIR
	mov	a,#0x80
	movx	@dptr,a

	lcall	X1243
	lcall	X071e

;fill EP8IN FIFO with 30 bytes from the fpga FIFO
	mov	r2,#0
	mov	r3,#0
X087f:
	clr	c
	mov	a,r2
	subb	a,#0x1e
	mov	a,r3
	subb	a,#0
	jnc	X089f

	mov	dptr,#X8800
	movx	a,@dptr
	mov	variable47,a
	mov	dptr,#X880b
	movx	a,@dptr
	mov	variable47,a
	;why did we overwrite the value we had just saved to variable47 ?

	mov	dptr,#IN8DATA
	movx	@dptr,a ;transfer a byte from external FIFO (fpga?) to isochronous EP8IN FIFO
	inc	r2
	cjne	r2,#0,X089d
	inc	r3
X089d:
	sjmp	X087f

X089f:
	lcall	X03e1
	mov	dptr,#USBCS
	clr	a
	movx	@dptr,a

;sleep a lot:
	mov	r2,#0
	mov	r3,#0
X08ab:
	mov	rb0r4,r2
	mov	rb0r5,r3
	clr	c
	mov	a,r2
	subb	a,#0x0e0
	mov	a,r3
	subb	a,#0x2e
	jnc	X08d2

	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	lcall	sleep_a_bit
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2

	inc	r2
	cjne	r2,#0,X08d0
	inc	r3
X08d0:	sjmp	X08ab
;
X08d2:
	mov	dptr,#USBCS
	mov	a,#2
	movx	@dptr,a

	mov	dptr,#USBCS
	mov	a,#6
	movx	@dptr,a

	;setup EP0IN and EP2IN as valid
	mov	dptr,#IN07VAL
	mov	a,#5
	movx	@dptr,a

	;setup EP0OUT and EP2OUT as valid
	mov	dptr,#OUT07VAL
	mov	a,#5
	movx	@dptr,a

	mov	dptr,#IN07IEN
	clr	a
	movx	@dptr,a

	mov	dptr,#OUT07IEN
	mov	a,#5
	movx	@dptr,a

	mov	ie,#0x80
	mov	i2sta,#0x10

	mov	dptr,#USBIEN
	mov	a,#0x0b
	movx	@dptr,a

	mov	dptr,#FASTXFR
	mov	a,#0x88
	movx	@dptr,a

	mov	dptr,#USBIRQ
	mov	a,#8
	movx	@dptr,a

	mov	csr,#0x11
	mov	variable32,#1
	mov	got_EP2OUT_data,#0
	mov	got_EP2IN_data,#0

	push	rb0r4
	push	rb0r5
	lcall	X04f7
	pop	rb0r5
	pop	rb0r4

	mov	variable34,#0
	mov	variable35,#1
X092a:
	mov	dptr,#USBIEN
	mov	a,#3
	movx	@dptr,a
	mov	rb0r2,r4
	cjne	r2,#0,X0937
	sjmp	X093a
;
X0937:
	ljmp	X0a3f
;
X093a:
	mov	variable34,pB0_pB2
	mov	dptr,#OEB
	mov	a,#0x8f
	movx	@dptr,a

	mov	dptr,#OUTB
	mov	a,#8
	movx	@dptr,a

	mov	dptr,#OEB
	mov	a,#0x88
	movx	@dptr,a

	mov	dptr,#PINSB
	movx	a,@dptr
	mov	r2,a
	mov	a,#5
	anl	a,r2
	mov	pB0_pB2,a

	mov	dptr,#OEB
	mov	a,#0x8f
	movx	@dptr,a

	mov	dptr,#OUTB
	mov	a,#2
	movx	@dptr,a

	mov	dptr,#OEB
	mov	a,#0x82
	movx	@dptr,a

	mov	a,pB0_pB2
	add	a,acc
	mov	r2,a

	mov	dptr,#PINSB
	movx	a,@dptr
	anl	a,#5
	mov	r3,a
	orl	a,r2
	mov	pB0_pB2,a
	jz	X0988

;set general purpose output pin pA7 (why?):
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#OUTA
	mov	a,#0x80
	orl	a,r2
	movx	@dptr,a

X0988:
	mov	CHAR_COL,#0
	mov	CHAR_ROW,#0
	push	rb0r4
	push	rb0r5
	lcall	set_cursor_position
	pop	rb0r5
	pop	rb0r4

	mov	dptr,#X1713
	movx	a,@dptr
	mov	r2,a
	mov	a,#0x80
	add	a,r2
	mov	r2,a
	mov	a,pB0_pB2
	cjne	a,#4,X09d0
	cjne	r2,#0x0a0,X09aa
X09aa:
	jnc	X09d0
	mov	dptr,#X1713
	movx	a,@dptr
	inc	a
	mov	r3,a
	inc	r3
	mov	dptr,#X1713
	mov	a,r3
	movx	@dptr,a
	mov	dptr,#X1713
	movx	a,@dptr
	mov	r3,a
	mov	dptr,#X1715
	movx	@dptr,a

	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X04f7
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2

X09d0:
	mov	a,pB0_pB2
	cjne	a,#2,X09fb
	clr	c
	mov	a,#4
	subb	a,r2
	jnc	X09fb
	mov	dptr,#X1713
	movx	a,@dptr
	mov	r2,a
	dec	r2
	dec	r2
	mov	dptr,#X1713
	mov	a,r2
	movx	@dptr,a
	mov	dptr,#X1713
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X1715
	movx	@dptr,a
	push	rb0r4
	push	rb0r5
	lcall	X04f7
	pop	rb0r5
	pop	rb0r4
X09fb:
	mov	a,pB0_pB2
	cjne	a,#8,X0a1d
	mov	a,variable34
	jnz	X0a1d
	mov	a,#1
	add	a,variable35
	anl	a,#0x0f
	mov	variable35,a
	mov	variable75,variable35
	mov	variable76,#0
	push	rb0r4
	push	rb0r5
	lcall	X13fe
	pop	rb0r5
	pop	rb0r4
X0a1d:
	mov	a,pB0_pB2
	cjne	a,#1,X0a3f
	mov	a,variable34
	jnz	X0a3f
	mov	a,variable35
	add	a,#0x0ff
	anl	a,#0x0f
	mov	variable35,a
	mov	variable75,variable35
	mov	variable76,#0
	push	rb0r4
	push	rb0r5
	lcall	X13fe
	pop	rb0r5
	pop	rb0r4
X0a3f:
	push	rb0r4
	push	rb0r5
	lcall	sleep_a_bit
	pop	rb0r5
	pop	rb0r4

;clear general purpose output pin pA7 (why?):
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#OUTA
	mov	a,#0x7f
	anl	a,r2
	movx	@dptr,a

	mov	dptr,#OUTB
	mov	a,#8
	movx	@dptr,a
	clr	c
	mov	a,r4
	subb	a,#0
	mov	a,r5
	subb	a,#2
	jc	X0a6d

;pin pA6 is general purpose output... weird!
;TODO:
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r2,a
	jb	acc.6,X0a75
X0a6d:
	clr	c
	clr	a
	subb	a,r4
	mov	a,#8
	subb	a,r5
	jnc	X0a88
X0a75:

;toggle state of general purpose output pin pA6
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#OUTA
	mov	a,#0x40
	xrl	a,rb0r2
	movx	@dptr,a

	mov	r4,#0
	mov	r5,#0
	sjmp	X0a8d
;
X0a88:
	inc	r4
	cjne	r4,#0,X0a8d
	inc	r5
X0a8d:
	mov	a,variable38
	cjne	a,#1,X0aa0

	push	rb0r4
	push	rb0r5
	lcall	X04f7
	pop	rb0r5
	pop	rb0r4

	mov	variable38,#0
X0aa0:
	mov	a,got_EP2OUT_data
	jnz	consume_received_bulk_data
	ljmp	X092a

consume_received_bulk_data:
	mov	dptr,#OUT2BC
	movx	a,@dptr
	mov	r2,a
	jnz	select_message_type
	ljmp	_default

select_message_type:

;toggle state of general purpose output pin pA7
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#OUTA
	mov	a,#0x80
	xrl	a,rb0r2
	movx	@dptr,a

;first byte of bulk transfers is a code
;for each code we have a different routine
  
	mov	dptr,#OUT2BUF
	movx	a,@dptr
	mov	r2,a

;the following assembly code is equivalent
; to a C switch/case block

	cjne	r2,#FPGA_INIT, _not_fpga_init
	sjmp	dabusb_fpga_init

_not_fpga_init:
	ljmp	not_fpga_init

dabusb_fpga_init:
	mov	variable32,#0
	mov	r3,#0
X0ad0:	cjne	r3,#0x64,X0ad3
X0ad3:	jnc	X0af1
	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	lcall	sleep_a_bit
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2

	mov	dptr,#X880f
	movx	a,@dptr
	mov	variable47,a
	inc	r3
	sjmp	X0ad0

X0af1:
	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X071e
	lcall	X03e1
	lcall	X04f7
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2

	mov	CHAR_COL,#0
	mov	CHAR_ROW,#1
	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	set_cursor_position
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2

	mov	STRING_ADDR_LOW,	<string_DABUSB_v1_00
	mov	STRING_ADDR_HI,		>string_DABUSB_v1_00
	mov	STRING_ADDRESSING_MODE, INTERNAL_16BITS
	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	print_string
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	ljmp	_default

not_fpga_init:
	cjne	r2,#FPGA_CLEAR,not_fpga_clear

dabusb_fpga_clear:
;pin pC3 seems to be connected to the FPGA reset pin (active low)
;this routine keeps it low for a while to clear the device.

	mov	dptr,#OUTC
	mov	a,#0x20
	movx	@dptr,a

	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	sleep_a_bit
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2

	mov	dptr,#OUTC
	mov	a,#0x28
	movx	@dptr,a

	mov	r3,#0
X0b56:	cjne	r3,#0x0a,X0b59
X0b59:	jc	X0b5e
	ljmp	_default
X0b5e:
	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	lcall	sleep_a_bit
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2
	inc	r3
	sjmp	X0b56

not_fpga_clear:
	cjne	r2,#FPGA_LOAD_BITSTREAM,not_fpga_load_bitstream

	mov	dptr,#OUT2BC
	movx	a,@dptr
	mov	r3,a
	cjne	r3,#0x40,not_fpga_load_bitstream
	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	dabusb_fpga_load_bitstream
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	ljmp	_default

not_fpga_load_bitstream:
	cjne	r2,#0x10,X0bb3

;toggle state of general purpose output pin pA7
	mov	dptr,#OUTA
	movx	a,@dptr
	mov	r3,a
	mov	dptr,#OUTA
	mov	a,#0x80
	xrl	a,rb0r3
	movx	@dptr,a

	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X103d
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	ljmp	_default

X0bb3:
	cjne	r2,#0x11,X0bc8

	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X106a
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	ljmp	_default

X0bc8:
	cjne	r2,#0x12,X0bdd

	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X108f
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	ljmp	_default

X0bdd:
	cjne	r2,#0x13,X0beb

	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	mov	r3,a
	mov	dptr,#X8800
	movx	@dptr,a
	sjmp	_default

X0beb:
	cjne	r2,#0x14,X0bff

	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X11dd
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	sjmp	_default

X0bff:
	cjne	r2,#0x15,X0c1f

	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	mov	variable75,a
	mov	dptr,#OUT2BUF_OFFSET2
	movx	a,@dptr
	mov	variable76,a
	push	rb0r2
	push	rb0r4
	push	rb0r5
	lcall	X13fe
	pop	rb0r5
	pop	rb0r4
	pop	rb0r2
	sjmp	_default

X0c1f:
	cjne	r2,#0x16,_default

	push	rb0r4
	push	rb0r5
	lcall	X13a3
	pop	rb0r5
	pop	rb0r4

_default:
	;prepare next bulk transfer
	mov	dptr,#OUT2BC
	clr	a
	movx	@dptr,a
	mov	got_EP2OUT_data,#0
	ljmp	X092a

string_SUSPEND:
.ascii "SUSPEND"
.db 0

string_RESUME:
.ascii "RESUME"
.db 0

string_Vol:
.ascii " Vol "
.db 0

string_DABUSB_v1_00:
.ascii "DABUSB v1.00"
.db 0

SUDAV:
	push	acc
	push	b
	push	dpl
	push	dph
	push	rb0r2
	push	rb0r3
	push	rb0r4
	push	rb0r5
	push	rb0r6
	push	rb0r7
	push	rb0r0
	push	rb0r1
	push	psw
	mov	psw,#0
	push	DPS
	mov	DPS,#0

	mov	a,EXIF	; clear USB IRQ (INT2)
	clr	acc.4
	mov	EXIF,a

	mov	dptr,#USBIRQ
	mov	a,#1
	movx	@dptr,a
	mov	dptr,#SETUPDAT
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X7fe9
	movx	a,@dptr
	mov	r3,a
X0c92:
	cjne	r3,#0,X0c97
	sjmp	X0c9a
;
X0c97:
	ljmp	X0d38
;
X0c9a:
	cjne	r2,#0x80,X0cb1
	mov	dptr,#IN0BUF
	mov	a,#1
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BC
	mov	a,#2
	movx	@dptr,a
	ljmp	X0ecd
;
X0cb1:
	cjne	r2,#0x82,X0cb6
	sjmp	X0cb9
;
X0cb6:
	ljmp	X0d1d
;
X0cb9:
	mov	dptr,#X7fec
	movx	a,@dptr
	mov	r4,a
	cjne	r4,#1,X0cc1
X0cc1:
	jc	X0ce4
	clr	c
	mov	a,#7
	subb	a,r4
	jc	X0ce4
	mov	a,r4
	add	a,#0x0ff
	add	a,acc
	mov	r5,a
	add	a,#0xc6
	mov	dpl,a
	clr	a
	addc	a,#0x7f
	mov	dph,a
	movx	a,@dptr
	mov	r5,a
	anl	rb0r5,#1
	mov	dptr,#IN0BUF
	mov	a,r5
	movx	@dptr,a
	sjmp	X0d0f
;
X0ce4:	cjne	r4,#0x81,X0ce7
X0ce7:	jc	X0d0a
	clr	c
	mov	a,#0x87
	subb	a,r4
	jc	X0d0a
	mov	a,r4
	add	a,#0x7f
	add	a,acc
	mov	r4,a
	add	a,#0x0b6
	mov	dpl,a
	clr	a
	addc	a,#0x7f
	mov	dph,a
	movx	a,@dptr
	mov	r4,a
	anl	rb0r4,#1
	mov	dptr,#IN0BUF
	mov	a,r4
	movx	@dptr,a
	sjmp	X0d0f
;
X0d0a:
	mov	dptr,#IN0BUF
	clr	a
	movx	@dptr,a
X0d0f:
	mov	dptr,#IN0BUF_OFFSET1
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BC
	mov	a,#2
	movx	@dptr,a
	ljmp	X0ecd
;
X0d1d:
	cjne	r2,#0x81,X0d22
	sjmp	X0d25
;
X0d22:
	ljmp	X0ec5
;
X0d25:
	mov	dptr,#IN0BUF
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BUF_OFFSET1
	clr	a
	movx	@dptr,a
	mov	dptr,#IN0BC
	mov	a,#2
	movx	@dptr,a
	ljmp	X0ecd
;
X0d38:
	cjne	r3,#1,X0d68
	cjne	r2,#0,X0d41
	ljmp	X0ecd
;
X0d41:
	cjne	r2,#2,X0d55
	mov	variable59,#0
	push	rb0r2
	push	rb0r3
	lcall	X0ef0
	pop	rb0r3
	pop	rb0r2
	ljmp	X0ecd
;
X0d55:
	cjne	r2,#0x21,X0d5a
	sjmp	X0d5d
;
X0d5a:
	ljmp	X0ecd
;
X0d5d:
	mov	variable37,#1
	mov	dptr,#OUT0BC
	clr	a
	movx	@dptr,a
	ljmp	X0ecd
;
X0d68:
	cjne	r3,#3,X0d8a
	cjne	r2,#0,X0d71
	ljmp	X0ecd
;
X0d71:
	cjne	r2,#2,X0d76
	sjmp	X0d79
;
X0d76:
	ljmp	X0ecd
;
X0d79:
	mov	variable59,#1
	push	rb0r2
	push	rb0r3
	lcall	X0ef0
	pop	rb0r3
	pop	rb0r2
	ljmp	X0ecd
;
X0d8a:
	cjne	r3,#6,X0de1
	cjne	r2,#0x80,X0d92
	sjmp	X0d95
;
X0d92:
	ljmp	X0ec5
;
X0d95:
	mov	dptr,#X7feb
	movx	a,@dptr
	mov	r4,a
	cjne	r4,#1,X0db2
	mov	r4, >data_block2
	mov	r5, <data_block2
	mov	rb0r6,r5
	mov	r7,#0
	mov	dptr,#SUDPTRH
	mov	a,r6
	movx	@dptr,a
	mov	dptr,#SUDPTRL
	mov	a,r4
	movx	@dptr,a
	ljmp	X0ecd
;
X0db2:
	mov	dptr,#X7feb
	movx	a,@dptr
	mov	r4,a
	cjne	r4,#2,X0dbc
	sjmp	X0dbf
;
X0dbc:
	ljmp	X0ec5
;
X0dbf:
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r4,a
	cjne	r4,#0,X0dc9
	sjmp	X0dcc
;
X0dc9:
	ljmp	X0ec5
;
X0dcc:
	mov	r4, <data_block
	mov	r5, >data_block
	mov	rb0r6,r5
	mov	r7,#0
	mov	dptr,#SUDPTRH
	mov	a,r6
	movx	@dptr,a
	mov	dptr,#SUDPTRL
	mov	a,r4
	movx	@dptr,a
	ljmp	X0ecd
;
X0de1:
	cjne	r3,#7,X0de7
	ljmp	X0ec5
;
X0de7:
	cjne	r3,#8,X0dfa
	mov	r4,variable48
	mov	dptr,#IN0BUF
	mov	a,r4
	movx	@dptr,a
	mov	dptr,#IN0BC
	mov	a,#1
	movx	@dptr,a
	ljmp	X0ecd
;
X0dfa:
	cjne	r3,#9,X0e2e
	cjne	r2,#0,X0e02
	sjmp	X0e05
;
X0e02:
	ljmp	X0ec5
;
X0e05:
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r4,a
	clr	c
	mov	a,#1
	subb	a,r4
	jnc	X0e13
	ljmp	X0ec5
;
X0e13:
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r4,a
	cjne	r4,#0,X0e25
	mov	dptr,#X1721
	clr	a
	movx	@dptr,a
	mov	dptr,#X1722
	clr	a
	movx	@dptr,a
X0e25:
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	variable48,a
	ljmp	X0ecd
;
X0e2e:
	cjne	r3,#0x0a,X0e58
	cjne	r2,#0x81,X0e36
	sjmp	X0e39
;
X0e36:
	ljmp	X0ec5
;
X0e39:
	mov	dptr,#X7fec
	movx	a,@dptr
	mov	r2,a
	add	a,#0x20
	mov	r2,a
	clr	a
	addc	a,#0x17
	mov	r4,a
	mov	dpl,r2
	mov	dph,r4
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#IN0BUF
	movx	@dptr,a
	mov	dptr,#IN0BC
	mov	a,#1
	movx	@dptr,a
	ljmp	X0ecd
;
X0e58:
	cjne	r3,#0x0b,X0e5d
	sjmp	X0e60
;
X0e5d:
	ljmp	X0ea9
;
X0e60:
	mov	dptr,#X1720
	clr	a
	movx	@dptr,a
	mov	dptr,#X7fec
	movx	a,@dptr
	mov	r2,a
	cjne	r2,#1,X0e87
	mov	dptr,#X7fed
	movx	a,@dptr
	mov	r2,a
	cjne	r2,#0,X0e87
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X1721
	movx	@dptr,a
	push	rb0r3
	lcall	X04e2
	pop	rb0r3
	sjmp	X0ecd
;
X0e87:
	mov	dptr,#X7fec
	movx	a,@dptr
	mov	r2,a
	cjne	r2,#2,X0ecd
	mov	dptr,#X7fed
	movx	a,@dptr
	mov	r2,a
	cjne	r2,#0,X0ecd
	push	rb0r3
	lcall	X04ef
	pop	rb0r3
	mov	dptr,#X7fea
	movx	a,@dptr
	mov	r2,a
	mov	dptr,#X1722
	movx	@dptr,a
	sjmp	X0ecd
;
X0ea9:
	cjne	r3,#0x12,X0eae
	sjmp	X0ec5
;
X0eae:
	cjne	r3,#0x81,X0eb3
	sjmp	X0ec0
;
X0eb3:
	cjne	r3,#0x83,X0eb8
	sjmp	X0ec0
;
X0eb8:
	cjne	r3,#0x82,X0ebd
	sjmp	X0ec0
;
X0ebd:	cjne	r3,#0x84,X0ec5
X0ec0:	lcall	X064e
	sjmp	X0ecd
;
X0ec5:
	mov	dptr,#EP0CS
	mov	a,#3
	movx	@dptr,a
	sjmp	X0ed3
;
X0ecd:
	mov	dptr,#EP0CS
	mov	a,#2
	movx	@dptr,a
X0ed3:
	pop	DPS
	pop	psw
	pop	rb0r1
	pop	rb0r0
	pop	rb0r7
	pop	rb0r6
	pop	rb0r5
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2
	pop	dph
	pop	dpl
	pop	b
	pop	acc
	reti	

X0ef0:
	mov	dptr,#X7fec
	movx	a,@dptr
	mov	variable5a,a
	clr	c
	subb	a,#1
	jc	X0f18
	clr	c
	mov	a,#7
	subb	a,variable5a
	jc	X0f18
	mov	a,variable5a
	add	a,#0x0ff
	add	a,acc
	mov	r2,a
	add	a,#0x0c6
	mov	dpl,a
	clr	a
	addc	a,#0x7f
	mov	dph,a
	mov	r2,variable59
	mov	a,r2
	movx	@dptr,a
	sjmp	X0f3a
;
X0f18:
	clr	c
	mov	a,variable5a
	subb	a,#0x81
	jc	X0f3a
	clr	c
	mov	a,#0x87
	subb	a,variable5a
	jc	X0f3a
	mov	a,variable5a
	add	a,#0x0ff
	add	a,acc
	mov	r2,a
	add	a,#0x0b6
	mov	dpl,a
	clr	a
	addc	a,#0x7f
	mov	dph,a
	mov	r2,variable59
	mov	a,r2
	movx	@dptr,a
X0f3a:
	ret	

data_block:
X0f3b:
.db 0x09, 0x02, 0xba, 0x00, 0x03, 0x01, 0x00, 0x40
.db 0x00, 0x09, 0x04, 0x00, 0x00, 0x00, 0x01, 0x01
.db 0x00, 0x00, 0x09, 0x24, 0x01, 0x00, 0x01, 0x3d
.db 0x00, 0x01, 0x01, 0x0c, 0x24, 0x02, 0x01, 0x10
.db 0x07, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x0d
.db 0x24, 0x06, 0x03, 0x01, 0x02, 0x15, 0x00, 0x03
.db 0x00, 0x03, 0x00, 0x00, 0x09, 0x24, 0x03, 0x02
.db 0x01, 0x01, 0x00, 0x01, 0x00, 0x09, 0x24, 0x03
.db 0x04, 0x02, 0x03, 0x00, 0x03, 0x00, 0x09, 0x24
.db 0x03, 0x05, 0x03, 0x06, 0x00, 0x01, 0x00, 0x09
.db 0x04, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00
.db 0x09, 0x04, 0x01, 0x01, 0x01, 0x01, 0x02, 0x00

data_block2:
X0ffb:
.db 0x00, 0x07, 0x24, 0x01, 0x02, 0x01, 0x01, 0x00
.db 0x0b, 0x24, 0x02, 0x01, 0x02, 0x02, 0x10, 0x01
.db 0x80, 0xbb, 0x00, 0x09, 0x05, 0x88, 0x05, 0x00
.db 0x01, 0x01, 0x00, 0x00, 0x07, 0x25, 0x01, 0x00
.db 0x00, 0x00, 0x00, 0x09, 0x04, 0x02, 0x00, 0x02
.db 0x00, 0x00, 0x00, 0x00, 0x07, 0x05, 0x82, 0x02
.db 0x40, 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40
.db 0x00, 0x00, 0x09, 0x04, 0x02, 0x01, 0x03, 0x00
.db 0x00, 0x00, 0x00, 0x07, 0x05, 0x82, 0x02, 0x40
.db 0x00, 0x00, 0x07, 0x05, 0x02, 0x02, 0x40, 0x00
.db 0x00, 0x09, 0x05, 0x89, 0x05, 0xa0, 0x01, 0x01
.db 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00
.db 0x12, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x40
.db 0x47, 0x05, 0x99, 0x99, 0x00, 0x01, 0x00, 0x00
.db 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
.db 0x00, 0x09, 0x02, 0xba, 0x00, 0x03, 0x01, 0x00

X101b:	mov	r2,#0
X101d:	cjne	r2,#5,X1020
X1020:
	jnc	X1039
	mov	dptr,#I2CS
	movx	a,@dptr
	mov	r3,a
	jnb	acc.0,X102f
	mov	dptr,#X0001
	sjmp	X103c
;
X102f:
	push	rb0r2
	lcall	sleep_a_bit
	pop	rb0r2
	inc	r2
	sjmp	X101d
;
X1039:
	mov	dptr,#X0001
X103c:
	ret	
;
X103d:
	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	mov	r1,a
	inc	dptr
	movx	a,@dptr
	mov	r2,a
	inc	dptr
	movx	a,@dptr
	mov	r3,a
	mov	r4,#0
	mov	r5,#0x7e
	mov	a,r3
	jz	X1061
X104f:
	mov	dpl,r1
	mov	dph,r2
	movx	a,@dptr
	inc	dptr
	mov	r1,dpl
	mov	r2,dph
	mov	dpl,r4
	mov	dph,r5
	movx	@dptr,a
	inc	r4
	djnz	r3,X104f
X1061:
	mov	dptr,#OUT2BUF_OFFSET3
	movx	a,@dptr
	mov	dptr,#IN2BC
	movx	@dptr,a
	ret	
;
X106a:
	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	mov	r1,a
	inc	dptr
	movx	a,@dptr
	mov	r2,a
	inc	dptr
	movx	a,@dptr
	mov	r3,a
	mov	r4,#0x0c4
	mov	r5,#0x7d
	mov	a,r3
	jz	X1061
X107c:
	mov	dpl,r4
	mov	dph,r5
	movx	a,@dptr
	inc	r4
	mov	dpl,r1
	mov	dph,r2
	movx	@dptr,a
	inc	dptr
	mov	r1,dpl
	mov	r2,dph
	djnz	r3,X107c
	ret	
;
X108f:
	mov	dptr,#I2CS
	mov	a,#0x80
	movx	@dptr,a
	inc	DPS
	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	inc	DPS
	inc	dptr
	movx	@dptr,a
	lcall	X101b
	mov	dptr,#I2CDAT
	inc	DPS
	inc	dptr
	inc	dptr
	movx	a,@dptr
	mov	r1,a
	jz	X10c3
	inc	dptr
	inc	DPS
X10b0:
	mov	dptr,#I2CDAT
	inc	DPS
	movx	a,@dptr
	inc	dptr
	inc	DPS
	movx	@dptr,a
	push	rb0r1
	lcall	X101b
	pop	rb0r1
	djnz	r1,X10b0
X10c3:
	mov	dptr,#I2CS
	mov	a,#0x40
	movx	@dptr,a
	ret	

X10ca:
	mov	dptr,#X8802
	mov	a,#1
	movx	@dptr,a

lots_of_sleep_loops_in_this_code:
	mov	r2,#0
sleep_sleep:
	cjne	r2,#0x0ff,X10d5
X10d5:	jnc	X10e1
	push	rb0r2
	lcall	sleep_a_bit
	pop	rb0r2
	inc	r2
	sjmp	sleep_sleep
X10e1:
	ret

X10e2:
	mov	a,variable6b
	cjne	a,#0xC0,X10ef
;this seems to be unreachable code since every routine that
; calls X10e2 saves 0x80 to variable6b before calling it.
	mov	dptr,#X8803
	mov	a,variable6c
	movx	@dptr,a
	sjmp	X10f5

X10ef:
	mov	dptr,#X8802
	mov	a,variable6c
	movx	@dptr,a

;seems to be another sleep routine:
X10f5:
	mov	r2,#0
	mov	r3,#0
X10f9:
	clr	c
	mov	a,r2
	subb	a,#0x32
	mov	a,r3
	xrl	a,#0x80
	subb	a,#0x80
	jnc	X110b
	inc	r2
	cjne	r2,#0,X10f9
	inc	r3
	sjmp	X10f9
X110b:
	ret	

;the LCD display seems to have 2 lines of 16 chars
print_char:
	mov	dptr,#X8803
	mov	a,CHAR_TO_PRINT
	movx	@dptr,a
	inc	LCD_CHAR_POSITION

	mov	r2,#0
SLEEP:	cjne	r2,#0x28,X1119
X1119:	jnc	X111e
	inc	r2
	sjmp	SLEEP

X111e:
	mov	a,LCD_CHAR_POSITION
	cjne	a,#0x10,X112b

	;break line
	mov	dptr,#X8802
	mov	a,#0xc0
	movx	@dptr,a
	sjmp	X1139

X112b:
	mov	a,LCD_CHAR_POSITION
	cjne	a,#0x20,X1139

	;cursor moves back to beginning of first line
	mov	dptr,#X8802
	mov	a,#0x80
	movx	@dptr,a
	mov	LCD_CHAR_POSITION,#0
;
X1139:
	mov	r2,#0
SLEEP_MORE:	cjne	r2,#0x28,X113e
X113e:	jnc	X1143
	inc	r2
	sjmp	SLEEP_MORE
X1143:
	ret	

set_cursor_position:
	mov	a,CHAR_ROW
	jz	first_row
	sjmp	second_row

first_row:
	mov	r2,#0
	mov	LCD_CHAR_POSITION,#0
	sjmp	X1156

second_row:
	mov	r2,#0x40
	mov	LCD_CHAR_POSITION,#0x10
X1156:
	mov	a,CHAR_COL
	add	a,r2
	mov	r2,a
	mov	a,CHAR_COL
	add	a,LCD_CHAR_POSITION
	mov	LCD_CHAR_POSITION,a ; LCD_CHAR_POSITION += CHAR_COL

	mov	dptr,#X8802
	mov	a,#0x80
	add	a,r2			;a = CHAR_COL + (second_row ? 0xC0 : 0x80)
	movx	@dptr,a
	mov	r2,#0

another_sleep_loop:
	clr	c
	mov	a,r2
	xrl	a,#0x80
	subb	a,#0x0a8
	jnc	X1174
	inc	r2
	sjmp	another_sleep_loop
X1174:
	ret	

print_string:
	mov	r2,STRING_ADDR_LOW
	mov	r3,STRING_ADDR_HI
	mov	r4,STRING_ADDRESSING_MODE
next_char:
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	lcall	read_byte
	mov	r5,a
	jz	end_of_string
	mov	CHAR_TO_PRINT,r5
	push	rb0r2
	push	rb0r3
	push	rb0r4
	lcall	print_char
	pop	rb0r4
	pop	rb0r3
	pop	rb0r2
	inc	r2
	cjne	r2,#0,X119d
	inc	r3
X119d:
	sjmp	next_char
end_of_string:
	ret	

;TODO
X11a0:
	mov	a,variable73
	swap	a
	anl	a,#0x0f
	mov	r2,a
	anl	rb0r2,#0x0f
	clr	c
	mov	a,#9
	subb	a,r2
	jnc	X11b5
	mov	a,#0x37
	add	a,r2
	mov	r3,a
	sjmp	X11b9

X11b5:
	mov	a,#0x30
	add	a,r2
	mov	r3,a
X11b9:
	mov	CHAR_TO_PRINT,r3
	push	rb0r3
	lcall	print_char
	pop	rb0r3
	mov	r2,variable73
	anl	rb0r2,#0x0f
	clr	c
	mov	a,#9
	subb	a,r2
	jnc	X11d3
	mov	a,#0x37
	add	a,r2
	mov	r3,a
	sjmp	X11d7

X11d3:
	mov	a,#0x30
	add	a,r2
	mov	r3,a
X11d7:
	mov	CHAR_TO_PRINT,r3
	lcall	print_char
	ret

X11dd:
	mov	dptr,#OUT2BUF_OFFSET3
	movx	a,@dptr
	mov	r2,a
	jz	X11f3

	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	mov	CHAR_COL,a

	mov	dptr,#OUT2BUF_OFFSET2
	movx	a,@dptr
	mov	CHAR_ROW,a

	lcall	set_cursor_position
X11f3:
	mov	dptr,#OUT2BUF_LASTBYTE
	clr	a
	movx	@dptr,a

	mov	STRING_ADDR_LOW,	<X7dc4
	mov	STRING_ADDR_HI,		>X7dc4
	mov	STRING_ADDRESSING_MODE, EXTERNAL_16BITS
	lcall	print_string
	ret

dabusb_fpga_load_bitstream:
	mov	r2,#4
loop_bytes:
	cjne	r2,#0x40,X120a ; for (index=4; index<64; index++){
X120a:
	jnc	X1242
	mov	a,r2
;TODO How to declare macros?	add	a,#lo(OUT2BUF)
	add	a,#(OUT2BUF & 0xff)
	mov	dpl,a
	clr	a
	addc	a,#(OUT2BUF / 256)
	mov	dph,a
	movx	a,@dptr
	mov	r3,a ; r3 = [OUT2BUF+index] ; OUT2BUF is the usb bulk transfer buffer for endpoint out2
	mov	r4,#0
loop_bits:
	cjne	r4,#8,X121d
X121d:
	jnc	next_byte
	mov	rb0r5,r3
	mov	a,r5
	jnb	acc.7,bitstream_0bit

;x = special function pins (not affected by this routine)
; Several routines toggle pA7 just like these.
; pA0 seems to be a strobe for the bitstream data
; and it seem that pins pA1 and pA6 both receive the current bit value

bitstream_1bit:
	mov	dptr,#OUTA
	mov	a,#0x42		;01xx xx10
	movx	@dptr,a
	mov	a,#0x0c3	;11xx xx11
	movx	@dptr,a
	sjmp	next_bitstream_bit

bitstream_0bit:
	mov	dptr,#OUTA
	clr	a					;00xx xx00
	movx	@dptr,a
	mov	a,#0x81		;10xx xx01
	movx	@dptr,a

next_bitstream_bit:
	mov	a,r3
	add	a,acc
	mov	r3,a
	inc	r4
	sjmp	loop_bits

next_byte:
	inc	r2
	sjmp	loop_bytes
X1242:
	ret

X1243:
	mov	r2,#0
	mov	r3,#0x0ef
X1247:	cjne	r2,#0x10,X124a
X124a:	jnc	X126c
	mov	a,#0x11
	add	a,r3
	mov	r3,a
	add	a,#0
	mov	r4,a
	clr	a
	addc	a,#0x18
	mov	r5,a
	mov	dpl,r4
	mov	dph,r5
	clr	a
	movx	@dptr,a
	;[1800h + 11h*r2]=0

	mov	a,r2
	add	a,#0
	mov	dpl,a
	clr	a
	addc	a,#0x19
	mov	dph,a
	clr	a
	movx	@dptr,a
	;[1900h + r2]=0

	inc	r2
	sjmp	X1247
X126c:
	ret	

X126d:
	mov	a,#0x0f8
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	clr	a
	movx	@dptr,a
	mov	a,#0x0f9
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	clr	a
	movx	@dptr,a
	mov	a,#0x0fa
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	clr	a
	movx	@dptr,a
	mov	a,#0x0fb
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	clr	a
	movx	@dptr,a
	mov	a,#0x0ff
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	clr	a
	movx	@dptr,a
	ret	

X12b4:
	lcall	X03cb
	lcall	X126d
	mov	r2,#0x0c0
	mov	r3,#0x87
	mov	r4,#1
	mov	a,#1
	add	a,r2
	mov	r5,a
	clr	a
	addc	a,r3
	mov	r6,a
	mov	rb0r7,r4
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	mov	a,#1
	lcall	write_byte
	add	a,r5
	mov	r2,a
	clr	a
	addc	a,r6
	mov	r3,a
	mov	rb0r4,r7
	mov	dpl,r5
	mov	dph,r6
	mov	b,r7
	mov	a,#6
	lcall	write_byte
	mov	a,#1
	add	a,r2
	mov	r5,a
	clr	a
	addc	a,r3
	mov	r6,a
	mov	rb0r7,r4
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	clr	a
	lcall	write_byte
	mov	a,#1
	add	a,r5
	mov	r2,a
	clr	a
	addc	a,r6
	mov	r3,a
	mov	rb0r4,r7
	mov	dpl,r5
	mov	dph,r6
	mov	b,r7
	mov	a,#0x0b
	lcall	write_byte
	mov	a,#1
	add	a,r2
	mov	r5,a
	clr	a
	addc	a,r3
	mov	r6,a
	mov	rb0r7,r4
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	mov	a,#8
	lcall	write_byte
	mov	a,#1
	add	a,r5
	mov	r2,a
	clr	a
	addc	a,r6
	mov	r3,a
	mov	rb0r4,r7
	mov	dpl,r5
	mov	dph,r6
	mov	b,r7
	mov	a,#1
	lcall	write_byte
	add	a,r2
	mov	r5,a
	clr	a
	addc	a,r3
	mov	r6,a
	mov	rb0r7,r4
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	clr	a
	lcall	write_byte
	mov	a,#1
	add	a,r5
	mov	r2,a
	clr	a
	addc	a,r6
	mov	r3,a
	mov	rb0r4,r7
	mov	dpl,r5
	mov	dph,r6
	mov	b,r7
	mov	a,#3
	lcall	write_byte
	mov	r5,#0
X135c:	cjne	r5,#6,X135f
X135f:	jnc	X1373
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	inc	r2
	cjne	r2,#0,X136c
	inc	r3
X136c:
	clr	a
	lcall	write_byte
	inc	r5
	sjmp	X135c
;
X1373:
	mov	dpl,r2
	mov	dph,r3
	mov	b,r4
	mov	a,variable74
	lcall	write_byte
	mov	a,#0x0f9
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	mov	a,#0x0f
	movx	@dptr,a
	mov	a,#0x0fe
	add	a,#0
	mov	dpl,a
	mov	a,#3
	addc	a,#0x84
	mov	dph,a
	mov	a,#1
	movx	@dptr,a
	lcall	X03e1
	lcall	X04f7
	ret	

X13a3:
	mov	dptr,#OUT2BUF_OFFSET1
	movx	a,@dptr
	mov	r2,a
	add	a,#0
	mov	r3,a
	clr	a
	addc	a,#0x19
	mov	r4,a
	mov	dptr,#OUT2BUF_OFFSET2
	movx	a,@dptr
	mov	r5,a
	mov	dpl,r3
	mov	dph,r4
	movx	@dptr,a
	mov	b,#0x11
	mov	a,r2
	mul	ab
	mov	r2,a
	mov	r3,#0
X13c1:	cjne	r3,#0x10,X13c4
X13c4:	jnc	X13ea
	mov	a,r2
	add	a,#0
	mov	r4,a
	clr	a
	addc	a,#0x18
	mov	r5,a
	mov	a,r3
	add	a,r4
	mov	r4,a
	clr	a
	addc	a,r5
	mov	r5,a
	mov	a,#4
	add	a,r3
	add	a,#0x0c0
	mov	dpl,a
	clr	a
	addc	a,#0x7d
	mov	dph,a
	movx	a,@dptr
	mov	r6,a
	mov	dpl,r4
	mov	dph,r5
	movx	@dptr,a
	inc	r3
	sjmp	X13c1

X13ea:
; ext[0x1810 + r2] = 0
	mov	a,r2
	add	a,#0
	mov	r2,a
	clr	a
	addc	a,#0x18
	mov	r3,a
	mov	a,#0x10
	add	a,r2
	mov	dpl,a
	clr	a
	addc	a,r3
	mov	dph,a
	clr	a
	movx	@dptr,a
	ret	

X13fe:
	mov	a,variable76
	jz	X1404
	sjmp	X141a
;
X1404:
	mov	a,#0x0f
	anl	a,variable75
	mov	r2,a
	mov	variable75,r2
	add	a,#0
	mov	dpl,a
	clr	a
	addc	a,#0x19
	mov	dph,a
	movx	a,@dptr
	mov	variable74,a
	lcall	X12b4
X141a:
	lcall	X10ca
	mov	CHAR_COL,#0
	mov	CHAR_ROW,#0
	lcall	set_cursor_position
	mov	STRING_ADDR_LOW,	<string_Prog
	mov	STRING_ADDR_HI,		>string_Prog
	mov	STRING_ADDRESSING_MODE, INTERNAL_16BITS
	lcall	print_string
	mov	a,variable76
	cjne	a,#2,X143b
	mov	a,#1
	sjmp	X143c
;
X143b:
	clr	a
X143c:
	mov	r2,a
	jnz	X144e
	mov	a,#1
	add	a,variable75
	mov	variable73,a
	push	rb0r2
	lcall	X11a0
	pop	rb0r2
	sjmp	X1458
;
X144e:
	mov	variable73,variable75
	push	rb0r2
	lcall	X11a0
	pop	rb0r2
X1458:
	mov	CHAR_COL,#0
	mov	CHAR_ROW,#1
	push	rb0r2
	lcall	set_cursor_position
	pop	rb0r2

	mov	a,r2
	jnz	X1482
	mov	b,#0x11
	mov	a,variable75
	mul	ab
	mov	r2,a
	add	a,#0
	mov	r2,a
	clr	a
	addc	a,#0x18
	mov	r3,a
	mov	STRING_ADDR_LOW,r2
	mov	STRING_ADDR_HI,r3
	mov	STRING_ADDRESSING_MODE, EXTERNAL_16BITS
	lcall	print_string
	sjmp	X14b8
;
X1482:
	mov	r2,#0
X1484:	cjne	r2,#0x10,X1487
X1487:	jnc	X14b8
	mov	a,r2
	add	a,#0
	mov	dpl,a
	clr	a
	addc	a,#0x19
	mov	dph,a
	movx	a,@dptr
	mov	r3,a
	mov	a,variable75
	cjne	a,rb0r3,X14b5
	mov	b,#0x11
	mov	a,r2
	mul	ab
	mov	r3,a
	add	a,#0
	mov	r3,a
	clr	a
	addc	a,#0x18
	mov	r4,a
	mov	STRING_ADDR_LOW,r3
	mov	STRING_ADDR_HI,r4
	mov	STRING_ADDRESSING_MODE, EXTERNAL_16BITS
	push	rb0r2
	lcall	print_string
	pop	rb0r2
X14b5:
	inc	r2
	sjmp	X1484
X14b8:
	ret

string_Prog:
.ascii "Prog "
.db 0

write_byte:
	xch a,r0
	push acc
	xch	a,r0
	push acc
	mov	a,b
	jz	to_8bit_internal_address
	dec	a
	jz	to_16bit_external_address
	dec	a
	jz	to_16bit_internal_address
	dec	a
	jz	to_8bit_external_address
	sjmp	byte_written

to_8bit_internal_address:
	pop	acc
	mov	r0,dpl
	mov	@r0,a
	sjmp	byte_written

to_16bit_external_address:
	pop	acc
	movx	@dptr,a
	sjmp	byte_written

to_16bit_internal_address:
	pop	acc
; DO NOTHING?
	sjmp	byte_written

to_8bit_external_address:
	pop	acc
	mov	r0,dpl
	movx	@r0,a

byte_written:
	xch	a,r0
	pop	acc
	xch	a,r0
	ret	

read_byte:
	xch	a,r0
	push	acc
	mov	a,b
	jz	from_8bit_internal_address
	dec	a
	jz	from_16bit_external_address
	dec	a
	jz	from_16bit_internal_address
	dec	a
	jz	from_8bit_external_address
	mov	a,#0x0ff
	sjmp	return_byte

from_8bit_internal_address:
	mov	r0,dpl
	mov	a,@r0
	sjmp	return_byte

from_16bit_external_address:
	movx	a,@dptr
	sjmp	return_byte

from_16bit_internal_address:
	clr	a
	movc	a,@a+dptr
	sjmp	return_byte

from_8bit_external_address:
	mov	r0,dpl
	movx	a,@r0

return_byte:
	mov	r0,a
	pop	acc
	xch	a,r0
	ret	

